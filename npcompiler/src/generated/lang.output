Terminals unused in grammar

   ','


Grammar

    0 $accept: module $end

    1 module: module0
    2       | module module0

    3 module0: PROGRAM IDENTIFIER prog_decl stmt_list end_program
    4        | FUNCTION IDENTIFIER function stmt_list end_function
    5        | FUNCTION_BLOCK IDENTIFIER function end_function_block

    6 end_program: END_PROGRAM

    7 end_function: END_FUNCTION

    8 end_function_block: END_FUNCTION_BLOCK

    9 function: function0
   10         | function function0

   11 function0: var_decl_local

   12 stmt_list: %empty
   13          | stmt_list stmt

   14 stmt: assignment
   15     | if_stmt

   16 semicolon: error
   17          | ';'

   18 assignment: IDENTIFIER ASSIGNMENT exp semicolon

   19 var_type: VT_I8
   20         | VT_U8
   21         | VT_I16
   22         | VT_U16
   23         | VT_I32
   24         | VT_U32
   25         | VT_REAL
   26         | VT_BOOL

   27 prog_decl: %empty
   28          | prog_decl var_decl_local
   29          | prog_decl var_decl_global

   30 $@1: %empty

   31 var_decl_local: VAR $@1 var_decl_seq END_VAR

   32 var_decl_seq: %empty
   33             | var_decl_seq var_decl0

   34 $@2: %empty

   35 var_decl_global: VAR_GLOBAL $@2 var_decl_seq_global END_VAR

   36 var_decl_seq_global: %empty
   37                    | var_decl_seq_global var_decl0

   38 var_decl0: IDENTIFIER ':' var_type ';'

   39 if_stmt: IF logical_exp THEN stmt_list else_clause

   40 else_clause: ELSIF logical_exp THEN stmt_list else_clause
   41            | ELSE stmt_list END_IF
   42            | END_IF

   43 number: NUMBER_DISCRETE
   44       | NUMBER_INTEGER
   45       | NUMBER_FLOAT

   46 logical_exp: exp
   47            | exp '<' exp
   48            | exp LE exp
   49            | exp '>' exp
   50            | exp GE

   51 exp: '(' exp ')'
   52    | '-' exp
   53    | '+' exp
   54    | exp '+' exp
   55    | exp '-' exp
   56    | exp '*' exp
   57    | exp '/' exp
   58    | number
   59    | IDENTIFIER
   60    | EXTERNAL_IDENTIFIER


Terminals, with rules where they appear

$end (0) 0
'(' (40) 51
')' (41) 51
'*' (42) 56
'+' (43) 53 54
',' (44)
'-' (45) 52 55
'/' (47) 57
':' (58) 38
';' (59) 17 38
'<' (60) 47
'>' (62) 49
error (256) 16
PROGRAM (258) 3
END_PROGRAM (259) 6
FUNCTION (260) 4
END_FUNCTION (261) 7
FUNCTION_BLOCK (262) 5
END_FUNCTION_BLOCK (263) 8
VAR (264) 31
VAR_GLOBAL (265) 35
END_VAR (266) 31 35
IDENTIFIER <val_str> (267) 3 4 5 18 38 59
EXTERNAL_IDENTIFIER <val_str> (268) 60
GE (269) 50
LE (270) 48
ASSIGNMENT (271) 18
IF (272) 39
THEN (273) 39 40
ELSIF (274) 40
ELSE (275) 41
END_IF (276) 41 42
NUMBER_DISCRETE <val_discrete> (277) 43
NUMBER_INTEGER <val_int> (278) 44
NUMBER_FLOAT <val_float> (279) 45
VT_I8 (280) 19
VT_U8 (281) 20
VT_I16 (282) 21
VT_U16 (283) 22
VT_I32 (284) 23
VT_U32 (285) 24
VT_REAL (286) 25
VT_BOOL (287) 26


Nonterminals, with rules where they appear

$accept (44)
    on left: 0
module <val_node> (45)
    on left: 1 2, on right: 0 2
module0 <val_node> (46)
    on left: 3 4 5, on right: 1 2
end_program (47)
    on left: 6, on right: 3
end_function (48)
    on left: 7, on right: 4
end_function_block (49)
    on left: 8, on right: 5
function <val_node> (50)
    on left: 9 10, on right: 4 5 10
function0 <val_node> (51)
    on left: 11, on right: 9 10
stmt_list <val_node> (52)
    on left: 12 13, on right: 3 4 13 39 40 41
stmt <val_node> (53)
    on left: 14 15, on right: 13
semicolon (54)
    on left: 16 17, on right: 18
assignment <val_node> (55)
    on left: 18, on right: 14
var_type <val_int> (56)
    on left: 19 20 21 22 23 24 25 26, on right: 38
prog_decl <val_node> (57)
    on left: 27 28 29, on right: 3 28 29
var_decl_local <val_node> (58)
    on left: 31, on right: 11 28
$@1 (59)
    on left: 30, on right: 31
var_decl_seq <val_node> (60)
    on left: 32 33, on right: 31 33
var_decl_global <val_node> (61)
    on left: 35, on right: 29
$@2 (62)
    on left: 34, on right: 35
var_decl_seq_global <val_node> (63)
    on left: 36 37, on right: 35 37
var_decl0 <val_node> (64)
    on left: 38, on right: 33 37
if_stmt <val_node> (65)
    on left: 39, on right: 15
else_clause (66)
    on left: 40 41 42, on right: 39 40
number <val_node> (67)
    on left: 43 44 45, on right: 58
logical_exp (68)
    on left: 46 47 48 49 50, on right: 39 40
exp <val_node> (69)
    on left: 51 52 53 54 55 56 57 58 59 60, on right: 18 46 47 48 49
    50 51 52 53 54 55 56 57


State 0

    0 $accept: . module $end
    1 module: . module0
    2       | . module module0
    3 module0: . PROGRAM IDENTIFIER prog_decl stmt_list end_program
    4        | . FUNCTION IDENTIFIER function stmt_list end_function
    5        | . FUNCTION_BLOCK IDENTIFIER function end_function_block

    PROGRAM         shift, and go to state 1
    FUNCTION        shift, and go to state 2
    FUNCTION_BLOCK  shift, and go to state 3

    module   go to state 4
    module0  go to state 5


State 1

    3 module0: PROGRAM . IDENTIFIER prog_decl stmt_list end_program

    IDENTIFIER  shift, and go to state 6


State 2

    4 module0: FUNCTION . IDENTIFIER function stmt_list end_function

    IDENTIFIER  shift, and go to state 7


State 3

    5 module0: FUNCTION_BLOCK . IDENTIFIER function end_function_block

    IDENTIFIER  shift, and go to state 8


State 4

    0 $accept: module . $end
    2 module: module . module0
    3 module0: . PROGRAM IDENTIFIER prog_decl stmt_list end_program
    4        | . FUNCTION IDENTIFIER function stmt_list end_function
    5        | . FUNCTION_BLOCK IDENTIFIER function end_function_block

    $end            shift, and go to state 9
    PROGRAM         shift, and go to state 1
    FUNCTION        shift, and go to state 2
    FUNCTION_BLOCK  shift, and go to state 3

    module0  go to state 10


State 5

    1 module: module0 .

    $default  reduce using rule 1 (module)


State 6

    3 module0: PROGRAM IDENTIFIER . prog_decl stmt_list end_program
   27 prog_decl: . %empty
   28          | . prog_decl var_decl_local
   29          | . prog_decl var_decl_global

    $default  reduce using rule 27 (prog_decl)

    prog_decl  go to state 11


State 7

    4 module0: FUNCTION IDENTIFIER . function stmt_list end_function
    9 function: . function0
   10         | . function function0
   11 function0: . var_decl_local
   31 var_decl_local: . VAR $@1 var_decl_seq END_VAR

    VAR  shift, and go to state 12

    function        go to state 13
    function0       go to state 14
    var_decl_local  go to state 15


State 8

    5 module0: FUNCTION_BLOCK IDENTIFIER . function end_function_block
    9 function: . function0
   10         | . function function0
   11 function0: . var_decl_local
   31 var_decl_local: . VAR $@1 var_decl_seq END_VAR

    VAR  shift, and go to state 12

    function        go to state 16
    function0       go to state 14
    var_decl_local  go to state 15


State 9

    0 $accept: module $end .

    $default  accept


State 10

    2 module: module module0 .

    $default  reduce using rule 2 (module)


State 11

    3 module0: PROGRAM IDENTIFIER prog_decl . stmt_list end_program
   12 stmt_list: . %empty  [END_PROGRAM, IDENTIFIER, IF]
   13          | . stmt_list stmt
   28 prog_decl: prog_decl . var_decl_local
   29          | prog_decl . var_decl_global
   31 var_decl_local: . VAR $@1 var_decl_seq END_VAR
   35 var_decl_global: . VAR_GLOBAL $@2 var_decl_seq_global END_VAR

    VAR         shift, and go to state 12
    VAR_GLOBAL  shift, and go to state 17

    $default  reduce using rule 12 (stmt_list)

    stmt_list        go to state 18
    var_decl_local   go to state 19
    var_decl_global  go to state 20


State 12

   30 $@1: . %empty
   31 var_decl_local: VAR . $@1 var_decl_seq END_VAR

    $default  reduce using rule 30 ($@1)

    $@1  go to state 21


State 13

    4 module0: FUNCTION IDENTIFIER function . stmt_list end_function
   10 function: function . function0
   11 function0: . var_decl_local
   12 stmt_list: . %empty  [END_FUNCTION, IDENTIFIER, IF]
   13          | . stmt_list stmt
   31 var_decl_local: . VAR $@1 var_decl_seq END_VAR

    VAR  shift, and go to state 12

    $default  reduce using rule 12 (stmt_list)

    function0       go to state 22
    stmt_list       go to state 23
    var_decl_local  go to state 15


State 14

    9 function: function0 .

    $default  reduce using rule 9 (function)


State 15

   11 function0: var_decl_local .

    $default  reduce using rule 11 (function0)


State 16

    5 module0: FUNCTION_BLOCK IDENTIFIER function . end_function_block
    8 end_function_block: . END_FUNCTION_BLOCK
   10 function: function . function0
   11 function0: . var_decl_local
   31 var_decl_local: . VAR $@1 var_decl_seq END_VAR

    END_FUNCTION_BLOCK  shift, and go to state 24
    VAR                 shift, and go to state 12

    end_function_block  go to state 25
    function0           go to state 22
    var_decl_local      go to state 15


State 17

   34 $@2: . %empty
   35 var_decl_global: VAR_GLOBAL . $@2 var_decl_seq_global END_VAR

    $default  reduce using rule 34 ($@2)

    $@2  go to state 26


State 18

    3 module0: PROGRAM IDENTIFIER prog_decl stmt_list . end_program
    6 end_program: . END_PROGRAM
   13 stmt_list: stmt_list . stmt
   14 stmt: . assignment
   15     | . if_stmt
   18 assignment: . IDENTIFIER ASSIGNMENT exp semicolon
   39 if_stmt: . IF logical_exp THEN stmt_list else_clause

    END_PROGRAM  shift, and go to state 27
    IDENTIFIER   shift, and go to state 28
    IF           shift, and go to state 29

    end_program  go to state 30
    stmt         go to state 31
    assignment   go to state 32
    if_stmt      go to state 33


State 19

   28 prog_decl: prog_decl var_decl_local .

    $default  reduce using rule 28 (prog_decl)


State 20

   29 prog_decl: prog_decl var_decl_global .

    $default  reduce using rule 29 (prog_decl)


State 21

   31 var_decl_local: VAR $@1 . var_decl_seq END_VAR
   32 var_decl_seq: . %empty
   33             | . var_decl_seq var_decl0

    $default  reduce using rule 32 (var_decl_seq)

    var_decl_seq  go to state 34


State 22

   10 function: function function0 .

    $default  reduce using rule 10 (function)


State 23

    4 module0: FUNCTION IDENTIFIER function stmt_list . end_function
    7 end_function: . END_FUNCTION
   13 stmt_list: stmt_list . stmt
   14 stmt: . assignment
   15     | . if_stmt
   18 assignment: . IDENTIFIER ASSIGNMENT exp semicolon
   39 if_stmt: . IF logical_exp THEN stmt_list else_clause

    END_FUNCTION  shift, and go to state 35
    IDENTIFIER    shift, and go to state 28
    IF            shift, and go to state 29

    end_function  go to state 36
    stmt          go to state 31
    assignment    go to state 32
    if_stmt       go to state 33


State 24

    8 end_function_block: END_FUNCTION_BLOCK .

    $default  reduce using rule 8 (end_function_block)


State 25

    5 module0: FUNCTION_BLOCK IDENTIFIER function end_function_block .

    $default  reduce using rule 5 (module0)


State 26

   35 var_decl_global: VAR_GLOBAL $@2 . var_decl_seq_global END_VAR
   36 var_decl_seq_global: . %empty
   37                    | . var_decl_seq_global var_decl0

    $default  reduce using rule 36 (var_decl_seq_global)

    var_decl_seq_global  go to state 37


State 27

    6 end_program: END_PROGRAM .

    $default  reduce using rule 6 (end_program)


State 28

   18 assignment: IDENTIFIER . ASSIGNMENT exp semicolon

    ASSIGNMENT  shift, and go to state 38


State 29

   39 if_stmt: IF . logical_exp THEN stmt_list else_clause
   43 number: . NUMBER_DISCRETE
   44       | . NUMBER_INTEGER
   45       | . NUMBER_FLOAT
   46 logical_exp: . exp
   47            | . exp '<' exp
   48            | . exp LE exp
   49            | . exp '>' exp
   50            | . exp GE
   51 exp: . '(' exp ')'
   52    | . '-' exp
   53    | . '+' exp
   54    | . exp '+' exp
   55    | . exp '-' exp
   56    | . exp '*' exp
   57    | . exp '/' exp
   58    | . number
   59    | . IDENTIFIER
   60    | . EXTERNAL_IDENTIFIER

    IDENTIFIER           shift, and go to state 39
    EXTERNAL_IDENTIFIER  shift, and go to state 40
    NUMBER_DISCRETE      shift, and go to state 41
    NUMBER_INTEGER       shift, and go to state 42
    NUMBER_FLOAT         shift, and go to state 43
    '+'                  shift, and go to state 44
    '-'                  shift, and go to state 45
    '('                  shift, and go to state 46

    number       go to state 47
    logical_exp  go to state 48
    exp          go to state 49


State 30

    3 module0: PROGRAM IDENTIFIER prog_decl stmt_list end_program .

    $default  reduce using rule 3 (module0)


State 31

   13 stmt_list: stmt_list stmt .

    $default  reduce using rule 13 (stmt_list)


State 32

   14 stmt: assignment .

    $default  reduce using rule 14 (stmt)


State 33

   15 stmt: if_stmt .

    $default  reduce using rule 15 (stmt)


State 34

   31 var_decl_local: VAR $@1 var_decl_seq . END_VAR
   33 var_decl_seq: var_decl_seq . var_decl0
   38 var_decl0: . IDENTIFIER ':' var_type ';'

    END_VAR     shift, and go to state 50
    IDENTIFIER  shift, and go to state 51

    var_decl0  go to state 52


State 35

    7 end_function: END_FUNCTION .

    $default  reduce using rule 7 (end_function)


State 36

    4 module0: FUNCTION IDENTIFIER function stmt_list end_function .

    $default  reduce using rule 4 (module0)


State 37

   35 var_decl_global: VAR_GLOBAL $@2 var_decl_seq_global . END_VAR
   37 var_decl_seq_global: var_decl_seq_global . var_decl0
   38 var_decl0: . IDENTIFIER ':' var_type ';'

    END_VAR     shift, and go to state 53
    IDENTIFIER  shift, and go to state 51

    var_decl0  go to state 54


State 38

   18 assignment: IDENTIFIER ASSIGNMENT . exp semicolon
   43 number: . NUMBER_DISCRETE
   44       | . NUMBER_INTEGER
   45       | . NUMBER_FLOAT
   51 exp: . '(' exp ')'
   52    | . '-' exp
   53    | . '+' exp
   54    | . exp '+' exp
   55    | . exp '-' exp
   56    | . exp '*' exp
   57    | . exp '/' exp
   58    | . number
   59    | . IDENTIFIER
   60    | . EXTERNAL_IDENTIFIER

    IDENTIFIER           shift, and go to state 39
    EXTERNAL_IDENTIFIER  shift, and go to state 40
    NUMBER_DISCRETE      shift, and go to state 41
    NUMBER_INTEGER       shift, and go to state 42
    NUMBER_FLOAT         shift, and go to state 43
    '+'                  shift, and go to state 44
    '-'                  shift, and go to state 45
    '('                  shift, and go to state 46

    number  go to state 47
    exp     go to state 55


State 39

   59 exp: IDENTIFIER .

    $default  reduce using rule 59 (exp)


State 40

   60 exp: EXTERNAL_IDENTIFIER .

    $default  reduce using rule 60 (exp)


State 41

   43 number: NUMBER_DISCRETE .

    $default  reduce using rule 43 (number)


State 42

   44 number: NUMBER_INTEGER .

    $default  reduce using rule 44 (number)


State 43

   45 number: NUMBER_FLOAT .

    $default  reduce using rule 45 (number)


State 44

   43 number: . NUMBER_DISCRETE
   44       | . NUMBER_INTEGER
   45       | . NUMBER_FLOAT
   51 exp: . '(' exp ')'
   52    | . '-' exp
   53    | . '+' exp
   53    | '+' . exp
   54    | . exp '+' exp
   55    | . exp '-' exp
   56    | . exp '*' exp
   57    | . exp '/' exp
   58    | . number
   59    | . IDENTIFIER
   60    | . EXTERNAL_IDENTIFIER

    IDENTIFIER           shift, and go to state 39
    EXTERNAL_IDENTIFIER  shift, and go to state 40
    NUMBER_DISCRETE      shift, and go to state 41
    NUMBER_INTEGER       shift, and go to state 42
    NUMBER_FLOAT         shift, and go to state 43
    '+'                  shift, and go to state 44
    '-'                  shift, and go to state 45
    '('                  shift, and go to state 46

    number  go to state 47
    exp     go to state 56


State 45

   43 number: . NUMBER_DISCRETE
   44       | . NUMBER_INTEGER
   45       | . NUMBER_FLOAT
   51 exp: . '(' exp ')'
   52    | . '-' exp
   52    | '-' . exp
   53    | . '+' exp
   54    | . exp '+' exp
   55    | . exp '-' exp
   56    | . exp '*' exp
   57    | . exp '/' exp
   58    | . number
   59    | . IDENTIFIER
   60    | . EXTERNAL_IDENTIFIER

    IDENTIFIER           shift, and go to state 39
    EXTERNAL_IDENTIFIER  shift, and go to state 40
    NUMBER_DISCRETE      shift, and go to state 41
    NUMBER_INTEGER       shift, and go to state 42
    NUMBER_FLOAT         shift, and go to state 43
    '+'                  shift, and go to state 44
    '-'                  shift, and go to state 45
    '('                  shift, and go to state 46

    number  go to state 47
    exp     go to state 57


State 46

   43 number: . NUMBER_DISCRETE
   44       | . NUMBER_INTEGER
   45       | . NUMBER_FLOAT
   51 exp: . '(' exp ')'
   51    | '(' . exp ')'
   52    | . '-' exp
   53    | . '+' exp
   54    | . exp '+' exp
   55    | . exp '-' exp
   56    | . exp '*' exp
   57    | . exp '/' exp
   58    | . number
   59    | . IDENTIFIER
   60    | . EXTERNAL_IDENTIFIER

    IDENTIFIER           shift, and go to state 39
    EXTERNAL_IDENTIFIER  shift, and go to state 40
    NUMBER_DISCRETE      shift, and go to state 41
    NUMBER_INTEGER       shift, and go to state 42
    NUMBER_FLOAT         shift, and go to state 43
    '+'                  shift, and go to state 44
    '-'                  shift, and go to state 45
    '('                  shift, and go to state 46

    number  go to state 47
    exp     go to state 58


State 47

   58 exp: number .

    $default  reduce using rule 58 (exp)


State 48

   39 if_stmt: IF logical_exp . THEN stmt_list else_clause

    THEN  shift, and go to state 59


State 49

   46 logical_exp: exp .  [THEN]
   47            | exp . '<' exp
   48            | exp . LE exp
   49            | exp . '>' exp
   50            | exp . GE
   54 exp: exp . '+' exp
   55    | exp . '-' exp
   56    | exp . '*' exp
   57    | exp . '/' exp

    GE   shift, and go to state 60
    LE   shift, and go to state 61
    '+'  shift, and go to state 62
    '-'  shift, and go to state 63
    '*'  shift, and go to state 64
    '/'  shift, and go to state 65
    '<'  shift, and go to state 66
    '>'  shift, and go to state 67

    $default  reduce using rule 46 (logical_exp)


State 50

   31 var_decl_local: VAR $@1 var_decl_seq END_VAR .

    $default  reduce using rule 31 (var_decl_local)


State 51

   38 var_decl0: IDENTIFIER . ':' var_type ';'

    ':'  shift, and go to state 68


State 52

   33 var_decl_seq: var_decl_seq var_decl0 .

    $default  reduce using rule 33 (var_decl_seq)


State 53

   35 var_decl_global: VAR_GLOBAL $@2 var_decl_seq_global END_VAR .

    $default  reduce using rule 35 (var_decl_global)


State 54

   37 var_decl_seq_global: var_decl_seq_global var_decl0 .

    $default  reduce using rule 37 (var_decl_seq_global)


State 55

   16 semicolon: . error
   17          | . ';'
   18 assignment: IDENTIFIER ASSIGNMENT exp . semicolon
   54 exp: exp . '+' exp
   55    | exp . '-' exp
   56    | exp . '*' exp
   57    | exp . '/' exp

    error  shift, and go to state 69
    '+'    shift, and go to state 62
    '-'    shift, and go to state 63
    '*'    shift, and go to state 64
    '/'    shift, and go to state 65
    ';'    shift, and go to state 70

    semicolon  go to state 71


State 56

   53 exp: '+' exp .  [error, GE, LE, THEN, '+', '-', ';', '<', '>', ')']
   54    | exp . '+' exp
   55    | exp . '-' exp
   56    | exp . '*' exp
   57    | exp . '/' exp

    '*'  shift, and go to state 64
    '/'  shift, and go to state 65

    $default  reduce using rule 53 (exp)

    Conflict between rule 53 and token '+' resolved as reduce (%left '+').
    Conflict between rule 53 and token '-' resolved as reduce (%left '-').
    Conflict between rule 53 and token '*' resolved as shift ('+' < '*').
    Conflict between rule 53 and token '/' resolved as shift ('+' < '/').


State 57

   52 exp: '-' exp .  [error, GE, LE, THEN, '+', '-', ';', '<', '>', ')']
   54    | exp . '+' exp
   55    | exp . '-' exp
   56    | exp . '*' exp
   57    | exp . '/' exp

    '*'  shift, and go to state 64
    '/'  shift, and go to state 65

    $default  reduce using rule 52 (exp)

    Conflict between rule 52 and token '+' resolved as reduce (%left '+').
    Conflict between rule 52 and token '-' resolved as reduce (%left '-').
    Conflict between rule 52 and token '*' resolved as shift ('-' < '*').
    Conflict between rule 52 and token '/' resolved as shift ('-' < '/').


State 58

   51 exp: '(' exp . ')'
   54    | exp . '+' exp
   55    | exp . '-' exp
   56    | exp . '*' exp
   57    | exp . '/' exp

    '+'  shift, and go to state 62
    '-'  shift, and go to state 63
    '*'  shift, and go to state 64
    '/'  shift, and go to state 65
    ')'  shift, and go to state 72


State 59

   12 stmt_list: . %empty
   13          | . stmt_list stmt
   39 if_stmt: IF logical_exp THEN . stmt_list else_clause

    $default  reduce using rule 12 (stmt_list)

    stmt_list  go to state 73


State 60

   50 logical_exp: exp GE .

    $default  reduce using rule 50 (logical_exp)


State 61

   43 number: . NUMBER_DISCRETE
   44       | . NUMBER_INTEGER
   45       | . NUMBER_FLOAT
   48 logical_exp: exp LE . exp
   51 exp: . '(' exp ')'
   52    | . '-' exp
   53    | . '+' exp
   54    | . exp '+' exp
   55    | . exp '-' exp
   56    | . exp '*' exp
   57    | . exp '/' exp
   58    | . number
   59    | . IDENTIFIER
   60    | . EXTERNAL_IDENTIFIER

    IDENTIFIER           shift, and go to state 39
    EXTERNAL_IDENTIFIER  shift, and go to state 40
    NUMBER_DISCRETE      shift, and go to state 41
    NUMBER_INTEGER       shift, and go to state 42
    NUMBER_FLOAT         shift, and go to state 43
    '+'                  shift, and go to state 44
    '-'                  shift, and go to state 45
    '('                  shift, and go to state 46

    number  go to state 47
    exp     go to state 74


State 62

   43 number: . NUMBER_DISCRETE
   44       | . NUMBER_INTEGER
   45       | . NUMBER_FLOAT
   51 exp: . '(' exp ')'
   52    | . '-' exp
   53    | . '+' exp
   54    | . exp '+' exp
   54    | exp '+' . exp
   55    | . exp '-' exp
   56    | . exp '*' exp
   57    | . exp '/' exp
   58    | . number
   59    | . IDENTIFIER
   60    | . EXTERNAL_IDENTIFIER

    IDENTIFIER           shift, and go to state 39
    EXTERNAL_IDENTIFIER  shift, and go to state 40
    NUMBER_DISCRETE      shift, and go to state 41
    NUMBER_INTEGER       shift, and go to state 42
    NUMBER_FLOAT         shift, and go to state 43
    '+'                  shift, and go to state 44
    '-'                  shift, and go to state 45
    '('                  shift, and go to state 46

    number  go to state 47
    exp     go to state 75


State 63

   43 number: . NUMBER_DISCRETE
   44       | . NUMBER_INTEGER
   45       | . NUMBER_FLOAT
   51 exp: . '(' exp ')'
   52    | . '-' exp
   53    | . '+' exp
   54    | . exp '+' exp
   55    | . exp '-' exp
   55    | exp '-' . exp
   56    | . exp '*' exp
   57    | . exp '/' exp
   58    | . number
   59    | . IDENTIFIER
   60    | . EXTERNAL_IDENTIFIER

    IDENTIFIER           shift, and go to state 39
    EXTERNAL_IDENTIFIER  shift, and go to state 40
    NUMBER_DISCRETE      shift, and go to state 41
    NUMBER_INTEGER       shift, and go to state 42
    NUMBER_FLOAT         shift, and go to state 43
    '+'                  shift, and go to state 44
    '-'                  shift, and go to state 45
    '('                  shift, and go to state 46

    number  go to state 47
    exp     go to state 76


State 64

   43 number: . NUMBER_DISCRETE
   44       | . NUMBER_INTEGER
   45       | . NUMBER_FLOAT
   51 exp: . '(' exp ')'
   52    | . '-' exp
   53    | . '+' exp
   54    | . exp '+' exp
   55    | . exp '-' exp
   56    | . exp '*' exp
   56    | exp '*' . exp
   57    | . exp '/' exp
   58    | . number
   59    | . IDENTIFIER
   60    | . EXTERNAL_IDENTIFIER

    IDENTIFIER           shift, and go to state 39
    EXTERNAL_IDENTIFIER  shift, and go to state 40
    NUMBER_DISCRETE      shift, and go to state 41
    NUMBER_INTEGER       shift, and go to state 42
    NUMBER_FLOAT         shift, and go to state 43
    '+'                  shift, and go to state 44
    '-'                  shift, and go to state 45
    '('                  shift, and go to state 46

    number  go to state 47
    exp     go to state 77


State 65

   43 number: . NUMBER_DISCRETE
   44       | . NUMBER_INTEGER
   45       | . NUMBER_FLOAT
   51 exp: . '(' exp ')'
   52    | . '-' exp
   53    | . '+' exp
   54    | . exp '+' exp
   55    | . exp '-' exp
   56    | . exp '*' exp
   57    | . exp '/' exp
   57    | exp '/' . exp
   58    | . number
   59    | . IDENTIFIER
   60    | . EXTERNAL_IDENTIFIER

    IDENTIFIER           shift, and go to state 39
    EXTERNAL_IDENTIFIER  shift, and go to state 40
    NUMBER_DISCRETE      shift, and go to state 41
    NUMBER_INTEGER       shift, and go to state 42
    NUMBER_FLOAT         shift, and go to state 43
    '+'                  shift, and go to state 44
    '-'                  shift, and go to state 45
    '('                  shift, and go to state 46

    number  go to state 47
    exp     go to state 78


State 66

   43 number: . NUMBER_DISCRETE
   44       | . NUMBER_INTEGER
   45       | . NUMBER_FLOAT
   47 logical_exp: exp '<' . exp
   51 exp: . '(' exp ')'
   52    | . '-' exp
   53    | . '+' exp
   54    | . exp '+' exp
   55    | . exp '-' exp
   56    | . exp '*' exp
   57    | . exp '/' exp
   58    | . number
   59    | . IDENTIFIER
   60    | . EXTERNAL_IDENTIFIER

    IDENTIFIER           shift, and go to state 39
    EXTERNAL_IDENTIFIER  shift, and go to state 40
    NUMBER_DISCRETE      shift, and go to state 41
    NUMBER_INTEGER       shift, and go to state 42
    NUMBER_FLOAT         shift, and go to state 43
    '+'                  shift, and go to state 44
    '-'                  shift, and go to state 45
    '('                  shift, and go to state 46

    number  go to state 47
    exp     go to state 79


State 67

   43 number: . NUMBER_DISCRETE
   44       | . NUMBER_INTEGER
   45       | . NUMBER_FLOAT
   49 logical_exp: exp '>' . exp
   51 exp: . '(' exp ')'
   52    | . '-' exp
   53    | . '+' exp
   54    | . exp '+' exp
   55    | . exp '-' exp
   56    | . exp '*' exp
   57    | . exp '/' exp
   58    | . number
   59    | . IDENTIFIER
   60    | . EXTERNAL_IDENTIFIER

    IDENTIFIER           shift, and go to state 39
    EXTERNAL_IDENTIFIER  shift, and go to state 40
    NUMBER_DISCRETE      shift, and go to state 41
    NUMBER_INTEGER       shift, and go to state 42
    NUMBER_FLOAT         shift, and go to state 43
    '+'                  shift, and go to state 44
    '-'                  shift, and go to state 45
    '('                  shift, and go to state 46

    number  go to state 47
    exp     go to state 80


State 68

   19 var_type: . VT_I8
   20         | . VT_U8
   21         | . VT_I16
   22         | . VT_U16
   23         | . VT_I32
   24         | . VT_U32
   25         | . VT_REAL
   26         | . VT_BOOL
   38 var_decl0: IDENTIFIER ':' . var_type ';'

    VT_I8    shift, and go to state 81
    VT_U8    shift, and go to state 82
    VT_I16   shift, and go to state 83
    VT_U16   shift, and go to state 84
    VT_I32   shift, and go to state 85
    VT_U32   shift, and go to state 86
    VT_REAL  shift, and go to state 87
    VT_BOOL  shift, and go to state 88

    var_type  go to state 89


State 69

   16 semicolon: error .

    $default  reduce using rule 16 (semicolon)


State 70

   17 semicolon: ';' .

    $default  reduce using rule 17 (semicolon)


State 71

   18 assignment: IDENTIFIER ASSIGNMENT exp semicolon .

    $default  reduce using rule 18 (assignment)


State 72

   51 exp: '(' exp ')' .

    $default  reduce using rule 51 (exp)


State 73

   13 stmt_list: stmt_list . stmt
   14 stmt: . assignment
   15     | . if_stmt
   18 assignment: . IDENTIFIER ASSIGNMENT exp semicolon
   39 if_stmt: . IF logical_exp THEN stmt_list else_clause
   39        | IF logical_exp THEN stmt_list . else_clause
   40 else_clause: . ELSIF logical_exp THEN stmt_list else_clause
   41            | . ELSE stmt_list END_IF
   42            | . END_IF

    IDENTIFIER  shift, and go to state 28
    IF          shift, and go to state 29
    ELSIF       shift, and go to state 90
    ELSE        shift, and go to state 91
    END_IF      shift, and go to state 92

    stmt         go to state 31
    assignment   go to state 32
    if_stmt      go to state 33
    else_clause  go to state 93


State 74

   48 logical_exp: exp LE exp .  [THEN]
   54 exp: exp . '+' exp
   55    | exp . '-' exp
   56    | exp . '*' exp
   57    | exp . '/' exp

    '+'  shift, and go to state 62
    '-'  shift, and go to state 63
    '*'  shift, and go to state 64
    '/'  shift, and go to state 65

    $default  reduce using rule 48 (logical_exp)


State 75

   54 exp: exp . '+' exp
   54    | exp '+' exp .  [error, GE, LE, THEN, '+', '-', ';', '<', '>', ')']
   55    | exp . '-' exp
   56    | exp . '*' exp
   57    | exp . '/' exp

    '*'  shift, and go to state 64
    '/'  shift, and go to state 65

    $default  reduce using rule 54 (exp)

    Conflict between rule 54 and token '+' resolved as reduce (%left '+').
    Conflict between rule 54 and token '-' resolved as reduce (%left '-').
    Conflict between rule 54 and token '*' resolved as shift ('+' < '*').
    Conflict between rule 54 and token '/' resolved as shift ('+' < '/').


State 76

   54 exp: exp . '+' exp
   55    | exp . '-' exp
   55    | exp '-' exp .  [error, GE, LE, THEN, '+', '-', ';', '<', '>', ')']
   56    | exp . '*' exp
   57    | exp . '/' exp

    '*'  shift, and go to state 64
    '/'  shift, and go to state 65

    $default  reduce using rule 55 (exp)

    Conflict between rule 55 and token '+' resolved as reduce (%left '+').
    Conflict between rule 55 and token '-' resolved as reduce (%left '-').
    Conflict between rule 55 and token '*' resolved as shift ('-' < '*').
    Conflict between rule 55 and token '/' resolved as shift ('-' < '/').


State 77

   54 exp: exp . '+' exp
   55    | exp . '-' exp
   56    | exp . '*' exp
   56    | exp '*' exp .  [error, GE, LE, THEN, '+', '-', '*', '/', ';', '<', '>', ')']
   57    | exp . '/' exp

    $default  reduce using rule 56 (exp)

    Conflict between rule 56 and token '+' resolved as reduce ('+' < '*').
    Conflict between rule 56 and token '-' resolved as reduce ('-' < '*').
    Conflict between rule 56 and token '*' resolved as reduce (%left '*').
    Conflict between rule 56 and token '/' resolved as reduce (%left '/').


State 78

   54 exp: exp . '+' exp
   55    | exp . '-' exp
   56    | exp . '*' exp
   57    | exp . '/' exp
   57    | exp '/' exp .  [error, GE, LE, THEN, '+', '-', '*', '/', ';', '<', '>', ')']

    $default  reduce using rule 57 (exp)

    Conflict between rule 57 and token '+' resolved as reduce ('+' < '/').
    Conflict between rule 57 and token '-' resolved as reduce ('-' < '/').
    Conflict between rule 57 and token '*' resolved as reduce (%left '*').
    Conflict between rule 57 and token '/' resolved as reduce (%left '/').


State 79

   47 logical_exp: exp '<' exp .  [THEN]
   54 exp: exp . '+' exp
   55    | exp . '-' exp
   56    | exp . '*' exp
   57    | exp . '/' exp

    '+'  shift, and go to state 62
    '-'  shift, and go to state 63
    '*'  shift, and go to state 64
    '/'  shift, and go to state 65

    $default  reduce using rule 47 (logical_exp)


State 80

   49 logical_exp: exp '>' exp .  [THEN]
   54 exp: exp . '+' exp
   55    | exp . '-' exp
   56    | exp . '*' exp
   57    | exp . '/' exp

    '+'  shift, and go to state 62
    '-'  shift, and go to state 63
    '*'  shift, and go to state 64
    '/'  shift, and go to state 65

    $default  reduce using rule 49 (logical_exp)


State 81

   19 var_type: VT_I8 .

    $default  reduce using rule 19 (var_type)


State 82

   20 var_type: VT_U8 .

    $default  reduce using rule 20 (var_type)


State 83

   21 var_type: VT_I16 .

    $default  reduce using rule 21 (var_type)


State 84

   22 var_type: VT_U16 .

    $default  reduce using rule 22 (var_type)


State 85

   23 var_type: VT_I32 .

    $default  reduce using rule 23 (var_type)


State 86

   24 var_type: VT_U32 .

    $default  reduce using rule 24 (var_type)


State 87

   25 var_type: VT_REAL .

    $default  reduce using rule 25 (var_type)


State 88

   26 var_type: VT_BOOL .

    $default  reduce using rule 26 (var_type)


State 89

   38 var_decl0: IDENTIFIER ':' var_type . ';'

    ';'  shift, and go to state 94


State 90

   40 else_clause: ELSIF . logical_exp THEN stmt_list else_clause
   43 number: . NUMBER_DISCRETE
   44       | . NUMBER_INTEGER
   45       | . NUMBER_FLOAT
   46 logical_exp: . exp
   47            | . exp '<' exp
   48            | . exp LE exp
   49            | . exp '>' exp
   50            | . exp GE
   51 exp: . '(' exp ')'
   52    | . '-' exp
   53    | . '+' exp
   54    | . exp '+' exp
   55    | . exp '-' exp
   56    | . exp '*' exp
   57    | . exp '/' exp
   58    | . number
   59    | . IDENTIFIER
   60    | . EXTERNAL_IDENTIFIER

    IDENTIFIER           shift, and go to state 39
    EXTERNAL_IDENTIFIER  shift, and go to state 40
    NUMBER_DISCRETE      shift, and go to state 41
    NUMBER_INTEGER       shift, and go to state 42
    NUMBER_FLOAT         shift, and go to state 43
    '+'                  shift, and go to state 44
    '-'                  shift, and go to state 45
    '('                  shift, and go to state 46

    number       go to state 47
    logical_exp  go to state 95
    exp          go to state 49


State 91

   12 stmt_list: . %empty
   13          | . stmt_list stmt
   41 else_clause: ELSE . stmt_list END_IF

    $default  reduce using rule 12 (stmt_list)

    stmt_list  go to state 96


State 92

   42 else_clause: END_IF .

    $default  reduce using rule 42 (else_clause)


State 93

   39 if_stmt: IF logical_exp THEN stmt_list else_clause .

    $default  reduce using rule 39 (if_stmt)


State 94

   38 var_decl0: IDENTIFIER ':' var_type ';' .

    $default  reduce using rule 38 (var_decl0)


State 95

   40 else_clause: ELSIF logical_exp . THEN stmt_list else_clause

    THEN  shift, and go to state 97


State 96

   13 stmt_list: stmt_list . stmt
   14 stmt: . assignment
   15     | . if_stmt
   18 assignment: . IDENTIFIER ASSIGNMENT exp semicolon
   39 if_stmt: . IF logical_exp THEN stmt_list else_clause
   41 else_clause: ELSE stmt_list . END_IF

    IDENTIFIER  shift, and go to state 28
    IF          shift, and go to state 29
    END_IF      shift, and go to state 98

    stmt        go to state 31
    assignment  go to state 32
    if_stmt     go to state 33


State 97

   12 stmt_list: . %empty
   13          | . stmt_list stmt
   40 else_clause: ELSIF logical_exp THEN . stmt_list else_clause

    $default  reduce using rule 12 (stmt_list)

    stmt_list  go to state 99


State 98

   41 else_clause: ELSE stmt_list END_IF .

    $default  reduce using rule 41 (else_clause)


State 99

   13 stmt_list: stmt_list . stmt
   14 stmt: . assignment
   15     | . if_stmt
   18 assignment: . IDENTIFIER ASSIGNMENT exp semicolon
   39 if_stmt: . IF logical_exp THEN stmt_list else_clause
   40 else_clause: . ELSIF logical_exp THEN stmt_list else_clause
   40            | ELSIF logical_exp THEN stmt_list . else_clause
   41            | . ELSE stmt_list END_IF
   42            | . END_IF

    IDENTIFIER  shift, and go to state 28
    IF          shift, and go to state 29
    ELSIF       shift, and go to state 90
    ELSE        shift, and go to state 91
    END_IF      shift, and go to state 92

    stmt         go to state 31
    assignment   go to state 32
    if_stmt      go to state 33
    else_clause  go to state 100


State 100

   40 else_clause: ELSIF logical_exp THEN stmt_list else_clause .

    $default  reduce using rule 40 (else_clause)
